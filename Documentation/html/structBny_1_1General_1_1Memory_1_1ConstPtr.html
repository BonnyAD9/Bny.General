<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bny.General: Bny.General.Memory.ConstPtr&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bny.General<span id="projectnumber">&#160;1.2.0</span>
   </div>
   <div id="projectbrief">Generally useful stuff</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structBny_1_1General_1_1Memory_1_1ConstPtr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="structBny_1_1General_1_1Memory_1_1ConstPtr-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Bny.General.Memory.ConstPtr&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan, but with pointer arithmetic operator overloads.  
 <a href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr_1_1Enumerator.html">Enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates data pointed to by a ConstPtr.  <a href="structBny_1_1General_1_1Memory_1_1ConstPtr_1_1Enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a684bdcf3260b5c2ac7e6f035998359d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a684bdcf3260b5c2ac7e6f035998359d9">ConstPtr</a> (ReadOnlySpan&lt; T &gt; span)</td></tr>
<tr class="memdesc:a684bdcf3260b5c2ac7e6f035998359d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates ConstPtr from ReadOnlySpan.  <br /></td></tr>
<tr class="separator:a684bdcf3260b5c2ac7e6f035998359d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87116039419f612bca002929d318b84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#ac87116039419f612bca002929d318b84">ConstPtr</a> (Span&lt; T &gt; span)</td></tr>
<tr class="memdesc:ac87116039419f612bca002929d318b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates ConstPtr from Span.  <br /></td></tr>
<tr class="separator:ac87116039419f612bca002929d318b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8711ad973ce892f379fe1486d9e3c882"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a8711ad973ce892f379fe1486d9e3c882">ConstPtr</a> (T[] arr)</td></tr>
<tr class="memdesc:a8711ad973ce892f379fe1486d9e3c882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates ConstPtr from an array.  <br /></td></tr>
<tr class="separator:a8711ad973ce892f379fe1486d9e3c882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d53972dde1b44ffeedc5cf6396d6d89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a8d53972dde1b44ffeedc5cf6396d6d89">ConstPtr</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1Ptr.html">Ptr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a8d53972dde1b44ffeedc5cf6396d6d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates ConstPtr from a Ptr.  <br /></td></tr>
<tr class="separator:a8d53972dde1b44ffeedc5cf6396d6d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b20b8d5b42bd03119d255e572b4d361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a7b20b8d5b42bd03119d255e572b4d361">Slice</a> (int start, int length)</td></tr>
<tr class="memdesc:a7b20b8d5b42bd03119d255e572b4d361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slice of the data in this ConstPtr.  <br /></td></tr>
<tr class="separator:a7b20b8d5b42bd03119d255e572b4d361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6f6f44d8c700d506f8d2fc981fd596"><td class="memItemLeft" align="right" valign="top">ref readonly T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a1f6f6f44d8c700d506f8d2fc981fd596">GetPinnableReference</a> ()</td></tr>
<tr class="memdesc:a1f6f6f44d8c700d506f8d2fc981fd596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the first item in the memory.  <br /></td></tr>
<tr class="separator:a1f6f6f44d8c700d506f8d2fc981fd596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba9218c2799624425dc9266de767518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr_1_1Enumerator.html">Enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#abba9218c2799624425dc9266de767518">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:abba9218c2799624425dc9266de767518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the data pointed to by this pointer.  <br /></td></tr>
<tr class="separator:abba9218c2799624425dc9266de767518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db0f3677698ef08e2fd50542a990f2a"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a9db0f3677698ef08e2fd50542a990f2a">Equals</a> (object? obj)</td></tr>
<tr class="memdesc:a9db0f3677698ef08e2fd50542a990f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always throws exception. Use the == operator instead.  <br /></td></tr>
<tr class="separator:a9db0f3677698ef08e2fd50542a990f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cf81089ffd8e91b2750624393c4ba7"><td class="memItemLeft" align="right" valign="top">override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a07cf81089ffd8e91b2750624393c4ba7">GetHashCode</a> ()</td></tr>
<tr class="memdesc:a07cf81089ffd8e91b2750624393c4ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always throw exceptrion.  <br /></td></tr>
<tr class="separator:a07cf81089ffd8e91b2750624393c4ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aebed92e4dafb9b050e6282628c87032f"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#aebed92e4dafb9b050e6282628c87032f">operator ConstPtr&lt; T &gt;</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1Ptr.html">Ptr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:aebed92e4dafb9b050e6282628c87032f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concerts Ptr to ConstPtr (same as the ConstPtr(Ptr) constructor)  <br /></td></tr>
<tr class="separator:aebed92e4dafb9b050e6282628c87032f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532b1910ce6b14eeac1919138c88bf0c"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a532b1910ce6b14eeac1919138c88bf0c">operator ReadOnlySpan&lt; T &gt;</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a532b1910ce6b14eeac1919138c88bf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ConstPtr to ReadOnlySpan.  <br /></td></tr>
<tr class="separator:a532b1910ce6b14eeac1919138c88bf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02da501329157e9ab31e8e6f4715d09"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#ad02da501329157e9ab31e8e6f4715d09">operator ConstPtr&lt; T &gt;</a> (ReadOnlySpan&lt; T &gt; span)</td></tr>
<tr class="memdesc:ad02da501329157e9ab31e8e6f4715d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ReadOnlySpan to ConstPtr (same as the ConstPtr(ReadOnlySpan) constructor)  <br /></td></tr>
<tr class="separator:ad02da501329157e9ab31e8e6f4715d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5560091cddd1c79b9359244368e09c"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#aef5560091cddd1c79b9359244368e09c">operator ConstPtr&lt; T &gt;</a> (Span&lt; T &gt; span)</td></tr>
<tr class="memdesc:aef5560091cddd1c79b9359244368e09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Span to ConstPtr (same as the ConstPtr(Span) constructor)  <br /></td></tr>
<tr class="separator:aef5560091cddd1c79b9359244368e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae6b47ec6163ae450279b80c9556cac"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a4ae6b47ec6163ae450279b80c9556cac">operator ConstPtr&lt; T &gt;</a> (T[] arr)</td></tr>
<tr class="memdesc:a4ae6b47ec6163ae450279b80c9556cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Array to ConstPtr (Same as the ConstPtr(Array) constructor)  <br /></td></tr>
<tr class="separator:a4ae6b47ec6163ae450279b80c9556cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8defdc29adc38504d450089b27fbfcef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a8defdc29adc38504d450089b27fbfcef">operator++</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a8defdc29adc38504d450089b27fbfcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the ConstPtr ('++ptr' has the same effect as 'ptr = ptr[1..]')  <br /></td></tr>
<tr class="separator:a8defdc29adc38504d450089b27fbfcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44038f419b3b498e7523abc724e7cfe1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a44038f419b3b498e7523abc724e7cfe1">operator true</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a44038f419b3b498e7523abc724e7cfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given ptr is not empty (has the same effect as ptr.Length != 0)  <br /></td></tr>
<tr class="separator:a44038f419b3b498e7523abc724e7cfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe46f016ea0f546b8394415ec17acf2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#adbe46f016ea0f546b8394415ec17acf2">operator false</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:adbe46f016ea0f546b8394415ec17acf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given ptr is empty (has the same effect as ptr.Length == 0)  <br /></td></tr>
<tr class="separator:adbe46f016ea0f546b8394415ec17acf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23a2856e18f73e458853d99131a2718"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#ac23a2856e18f73e458853d99131a2718">operator!</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:ac23a2856e18f73e458853d99131a2718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given ptr is empty (has the same effect as ptr.Length == 0)  <br /></td></tr>
<tr class="separator:ac23a2856e18f73e458853d99131a2718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e66ad0a5f075f18d9c677775ba3548"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#ad7e66ad0a5f075f18d9c677775ba3548">operator+</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr, int value)</td></tr>
<tr class="memdesc:ad7e66ad0a5f075f18d9c677775ba3548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given number to the ConstPtr ('ptr + 5' has the same effect as 'ptr[5..]')  <br /></td></tr>
<tr class="separator:ad7e66ad0a5f075f18d9c677775ba3548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99425997ea1b8f60b27b006583855efb"><td class="memItemLeft" align="right" valign="top">static unsafe int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a99425997ea1b8f60b27b006583855efb">operator-</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; p1, <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; p2)</td></tr>
<tr class="memdesc:a99425997ea1b8f60b27b006583855efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of elements bethween the given pointers that point to the same continuous block of memory. If the pointers not't point to the same memory, the behaviour is undefined.  <br /></td></tr>
<tr class="separator:a99425997ea1b8f60b27b006583855efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2248e0a928d6fc22e61d7c9671f53f7d"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a2248e0a928d6fc22e61d7c9671f53f7d">operator+</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a2248e0a928d6fc22e61d7c9671f53f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value that the pointer points to (Same as ptr.Value)  <br /></td></tr>
<tr class="separator:a2248e0a928d6fc22e61d7c9671f53f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f4f1b5d78060921b1844fdae1858e4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#ac6f4f1b5d78060921b1844fdae1858e4">operator==</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr1, <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr2)</td></tr>
<tr class="memdesc:ac6f4f1b5d78060921b1844fdae1858e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two pointers point to the same memory and have the same length. (This doesn't check the data itself)  <br /></td></tr>
<tr class="separator:ac6f4f1b5d78060921b1844fdae1858e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52b300a54d6b7ae4427e5543a483f86"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#ae52b300a54d6b7ae4427e5543a483f86">operator!=</a> (<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr1, <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; ptr2)</td></tr>
<tr class="memdesc:ae52b300a54d6b7ae4427e5543a483f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two pointers don't point to the same memory or don't have the same length (This doesn't check the data itself)  <br /></td></tr>
<tr class="separator:ae52b300a54d6b7ae4427e5543a483f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="properties" name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a9ef32802020ca372f16250b580c91460"><td class="memItemLeft" align="right" valign="top"><a id="a9ef32802020ca372f16250b580c91460" name="a9ef32802020ca372f16250b580c91460"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Length</b><code> [get]</code></td></tr>
<tr class="memdesc:a9ef32802020ca372f16250b580c91460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lenfth of the memory. <br /></td></tr>
<tr class="separator:a9ef32802020ca372f16250b580c91460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992f65ca309b7dff52f09ad753facc2e"><td class="memItemLeft" align="right" valign="top"><a id="a992f65ca309b7dff52f09ad753facc2e" name="a992f65ca309b7dff52f09ad753facc2e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>Value</b><code> [get]</code></td></tr>
<tr class="memdesc:a992f65ca309b7dff52f09ad753facc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value at the first position. <br /></td></tr>
<tr class="separator:a992f65ca309b7dff52f09ad753facc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e07c8ec004348ef702d5f9cd5d38432"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#a1e07c8ec004348ef702d5f9cd5d38432">this[int index]</a><code> [get]</code></td></tr>
<tr class="memdesc:a1e07c8ec004348ef702d5f9cd5d38432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the given index.  <br /></td></tr>
<tr class="separator:a1e07c8ec004348ef702d5f9cd5d38432"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan, but with pointer arithmetic operator overloads. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data in the memory</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a684bdcf3260b5c2ac7e6f035998359d9" name="a684bdcf3260b5c2ac7e6f035998359d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684bdcf3260b5c2ac7e6f035998359d9">&#9670;&#160;</a></span>ConstPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a> </td>
          <td>(</td>
          <td class="paramtype">ReadOnlySpan&lt; T &gt;&#160;</td>
          <td class="paramname"><em>span</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates ConstPtr from ReadOnlySpan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>ReadOnlySpan to create the ConstPtr from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac87116039419f612bca002929d318b84" name="ac87116039419f612bca002929d318b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87116039419f612bca002929d318b84">&#9670;&#160;</a></span>ConstPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a> </td>
          <td>(</td>
          <td class="paramtype">Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>span</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates ConstPtr from Span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>Span to create the ConstPtr from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8711ad973ce892f379fe1486d9e3c882" name="a8711ad973ce892f379fe1486d9e3c882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8711ad973ce892f379fe1486d9e3c882">&#9670;&#160;</a></span>ConstPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a> </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates ConstPtr from an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to create the ConstPtr from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d53972dde1b44ffeedc5cf6396d6d89" name="a8d53972dde1b44ffeedc5cf6396d6d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d53972dde1b44ffeedc5cf6396d6d89">&#9670;&#160;</a></span>ConstPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1Ptr.html">Ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates ConstPtr from a Ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Ptr to create the ConstPtr from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9db0f3677698ef08e2fd50542a990f2a" name="a9db0f3677698ef08e2fd50542a990f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db0f3677698ef08e2fd50542a990f2a">&#9670;&#160;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override bool <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.Equals </td>
          <td>(</td>
          <td class="paramtype">object?&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always throws exception. Use the == operator instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Doesn't matter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>Thrown always</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abba9218c2799624425dc9266de767518" name="abba9218c2799624425dc9266de767518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba9218c2799624425dc9266de767518">&#9670;&#160;</a></span>GetEnumerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr_1_1Enumerator.html">Enumerator</a> <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the data pointed to by this pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Enumerator that enumerates all the data in the memory pointed to by this pointer </dd></dl>

</div>
</div>
<a id="a07cf81089ffd8e91b2750624393c4ba7" name="a07cf81089ffd8e91b2750624393c4ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cf81089ffd8e91b2750624393c4ba7">&#9670;&#160;</a></span>GetHashCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override int <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.GetHashCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always throw exceptrion. </p>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>Thrown always</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f6f6f44d8c700d506f8d2fc981fd596" name="a1f6f6f44d8c700d506f8d2fc981fd596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6f6f44d8c700d506f8d2fc981fd596">&#9670;&#160;</a></span>GetPinnableReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ref readonly T <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.GetPinnableReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to the first item in the memory. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the firs item in the memory</dd></dl>

</div>
</div>
<a id="aebed92e4dafb9b050e6282628c87032f" name="aebed92e4dafb9b050e6282628c87032f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebed92e4dafb9b050e6282628c87032f">&#9670;&#160;</a></span>operator ConstPtr&lt; T &gt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1Ptr.html">Ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concerts Ptr to ConstPtr (same as the ConstPtr(Ptr) constructor) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The Ptr to convert to ConstPtr</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad02da501329157e9ab31e8e6f4715d09" name="ad02da501329157e9ab31e8e6f4715d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02da501329157e9ab31e8e6f4715d09">&#9670;&#160;</a></span>operator ConstPtr&lt; T &gt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">ReadOnlySpan&lt; T &gt;&#160;</td>
          <td class="paramname"><em>span</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts ReadOnlySpan to ConstPtr (same as the ConstPtr(ReadOnlySpan) constructor) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>The ReadOnlySpan to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef5560091cddd1c79b9359244368e09c" name="aef5560091cddd1c79b9359244368e09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5560091cddd1c79b9359244368e09c">&#9670;&#160;</a></span>operator ConstPtr&lt; T &gt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>span</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts Span to ConstPtr (same as the ConstPtr(Span) constructor) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>The Span to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ae6b47ec6163ae450279b80c9556cac" name="a4ae6b47ec6163ae450279b80c9556cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae6b47ec6163ae450279b80c9556cac">&#9670;&#160;</a></span>operator ConstPtr&lt; T &gt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts Array to ConstPtr (Same as the ConstPtr(Array) constructor) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The Array to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbe46f016ea0f546b8394415ec17acf2" name="adbe46f016ea0f546b8394415ec17acf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe46f016ea0f546b8394415ec17acf2">&#9670;&#160;</a></span>operator false()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator false </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given ptr is empty (has the same effect as ptr.Length == 0) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>ConstPtr to check if it is empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if ptr is empty, otherwise false</dd></dl>

</div>
</div>
<a id="a532b1910ce6b14eeac1919138c88bf0c" name="a532b1910ce6b14eeac1919138c88bf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532b1910ce6b14eeac1919138c88bf0c">&#9670;&#160;</a></span>operator ReadOnlySpan&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator ReadOnlySpan&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts ConstPtr to ReadOnlySpan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The ConstPtr to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44038f419b3b498e7523abc724e7cfe1" name="a44038f419b3b498e7523abc724e7cfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44038f419b3b498e7523abc724e7cfe1">&#9670;&#160;</a></span>operator true()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator true </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given ptr is not empty (has the same effect as ptr.Length != 0) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>ConstPtr to check if is empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if ptr is not empty, otherwise false</dd></dl>

</div>
</div>
<a id="ac23a2856e18f73e458853d99131a2718" name="ac23a2856e18f73e458853d99131a2718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23a2856e18f73e458853d99131a2718">&#9670;&#160;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator! </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given ptr is empty (has the same effect as ptr.Length == 0) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>ConstPtr to check if it is empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if ptr is empty, otherwise false</dd></dl>

</div>
</div>
<a id="ae52b300a54d6b7ae4427e5543a483f86" name="ae52b300a54d6b7ae4427e5543a483f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52b300a54d6b7ae4427e5543a483f86">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.<a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html#ac23a2856e18f73e458853d99131a2718">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the two pointers don't point to the same memory or don't have the same length (This doesn't check the data itself) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr1</td><td>Pointer to be compared with ptr2</td></tr>
    <tr><td class="paramname">ptr2</td><td>Pointer to be compared with ptr1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two pointers don't point to the same memory or don't have the same length, otherwise false </dd></dl>

</div>
</div>
<a id="a2248e0a928d6fc22e61d7c9671f53f7d" name="a2248e0a928d6fc22e61d7c9671f53f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2248e0a928d6fc22e61d7c9671f53f7d">&#9670;&#160;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value that the pointer points to (Same as ptr.Value) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to get the value from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first value of the pointer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the pointer length is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7e66ad0a5f075f18d9c677775ba3548" name="ad7e66ad0a5f075f18d9c677775ba3548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e66ad0a5f075f18d9c677775ba3548">&#9670;&#160;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given number to the ConstPtr ('ptr + 5' has the same effect as 'ptr[5..]') </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>ConstPtr to add the value to</td></tr>
    <tr><td class="paramname">value</td><td>Value to be added to the ConstPtr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ConstPtr with the given offset</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the added value is larger than the ptr.Length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8defdc29adc38504d450089b27fbfcef" name="a8defdc29adc38504d450089b27fbfcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8defdc29adc38504d450089b27fbfcef">&#9670;&#160;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator++ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the ConstPtr ('++ptr' has the same effect as 'ptr = ptr[1..]') </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>ConstPtr to increment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incremented ConstPtr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the ptr length is 0</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99425997ea1b8f60b27b006583855efb" name="a99425997ea1b8f60b27b006583855efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99425997ea1b8f60b27b006583855efb">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsafe int <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of elements bethween the given pointers that point to the same continuous block of memory. If the pointers not't point to the same memory, the behaviour is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The second part of memory</td></tr>
    <tr><td class="paramname">p2</td><td>The first part of memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements betwen the memory pointers</dd></dl>

</div>
</div>
<a id="ac6f4f1b5d78060921b1844fdae1858e4" name="ac6f4f1b5d78060921b1844fdae1858e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f4f1b5d78060921b1844fdae1858e4">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the two pointers point to the same memory and have the same length. (This doesn't check the data itself) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr1</td><td>Pointer to be compared with ptr2</td></tr>
    <tr><td class="paramname">ptr2</td><td>Pointer to be compared with ptr1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two pointers point to the same memory and have the same length</dd></dl>

</div>
</div>
<a id="a7b20b8d5b42bd03119d255e572b4d361" name="a7b20b8d5b42bd03119d255e572b4d361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b20b8d5b42bd03119d255e572b4d361">&#9670;&#160;</a></span>Slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a>&lt; T &gt; <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.Slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns slice of the data in this ConstPtr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start index of the slice</td></tr>
    <tr><td class="paramname">length</td><td>Size of the slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New ConstPtr over the specified range of the original ConstPtr </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the requested slice is out of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a1e07c8ec004348ef702d5f9cd5d38432" name="a1e07c8ec004348ef702d5f9cd5d38432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e07c8ec004348ef702d5f9cd5d38432">&#9670;&#160;</a></span>this[int index]</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">Bny.General.Memory.ConstPtr</a>&lt; T &gt;.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the value to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Bny.General/Memory/ConstPtr.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceBny.html">Bny</a></li><li class="navelem"><a class="el" href="namespaceBny_1_1General.html">General</a></li><li class="navelem"><a class="el" href="namespaceBny_1_1General_1_1Memory.html">Memory</a></li><li class="navelem"><a class="el" href="structBny_1_1General_1_1Memory_1_1ConstPtr.html">ConstPtr</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
