<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bny.General: ConstPtr&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bny.General<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Generally useful stuff</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('struct_const_ptr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="struct_const_ptr-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ConstPtr&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Read only version of <a class="el" href="struct_ptr.html" title="Mutable version of ConstPtr. Represents continuous memory. Similar to Span, but has pointer arithmeti...">Ptr</a>. Represents a countinuous region of read only memory. Same as ReadOnlySpan, but with pointer arithmetic operator overloads.   
 <a href="struct_const_ptr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr_1_1_enumerator.html">Enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates data pointed to by a <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a>   <a href="struct_const_ptr_1_1_enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a547b7919efc595fecc9881a62e9e6d96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a547b7919efc595fecc9881a62e9e6d96">ConstPtr</a> (ReadOnlySpan&lt; T &gt; span)</td></tr>
<tr class="memdesc:a547b7919efc595fecc9881a62e9e6d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from ReadOnlySpan   <a href="struct_const_ptr.html#a547b7919efc595fecc9881a62e9e6d96">More...</a><br /></td></tr>
<tr class="separator:a547b7919efc595fecc9881a62e9e6d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49747e26d4e6d46b31c5838792cff9fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a49747e26d4e6d46b31c5838792cff9fd">ConstPtr</a> (Span&lt; T &gt; span)</td></tr>
<tr class="memdesc:a49747e26d4e6d46b31c5838792cff9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from Span   <a href="struct_const_ptr.html#a49747e26d4e6d46b31c5838792cff9fd">More...</a><br /></td></tr>
<tr class="separator:a49747e26d4e6d46b31c5838792cff9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e53231531f0d4a4cb4eb861da3531a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a09e53231531f0d4a4cb4eb861da3531a">ConstPtr</a> (T[] arr)</td></tr>
<tr class="memdesc:a09e53231531f0d4a4cb4eb861da3531a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from an array   <a href="struct_const_ptr.html#a09e53231531f0d4a4cb4eb861da3531a">More...</a><br /></td></tr>
<tr class="separator:a09e53231531f0d4a4cb4eb861da3531a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d737ad0ba4caf11a9290b991e70079"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#ab6d737ad0ba4caf11a9290b991e70079">ConstPtr</a> (<a class="el" href="struct_ptr.html">Ptr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:ab6d737ad0ba4caf11a9290b991e70079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from a <a class="el" href="struct_ptr.html" title="Mutable version of ConstPtr. Represents continuous memory. Similar to Span, but has pointer arithmeti...">Ptr</a>   <a href="struct_const_ptr.html#ab6d737ad0ba4caf11a9290b991e70079">More...</a><br /></td></tr>
<tr class="separator:ab6d737ad0ba4caf11a9290b991e70079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc6a3adc1612fe5375e245b3dc24e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a4dc6a3adc1612fe5375e245b3dc24e44">Slice</a> (int start, int length)</td></tr>
<tr class="memdesc:a4dc6a3adc1612fe5375e245b3dc24e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slice of the data in this <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a>   <a href="struct_const_ptr.html#a4dc6a3adc1612fe5375e245b3dc24e44">More...</a><br /></td></tr>
<tr class="separator:a4dc6a3adc1612fe5375e245b3dc24e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf64b06a7b88784ae50437378a9661"><td class="memItemLeft" align="right" valign="top">ref readonly T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a68bf64b06a7b88784ae50437378a9661">GetPinnableReference</a> ()</td></tr>
<tr class="memdesc:a68bf64b06a7b88784ae50437378a9661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the first item in the memory   <a href="struct_const_ptr.html#a68bf64b06a7b88784ae50437378a9661">More...</a><br /></td></tr>
<tr class="separator:a68bf64b06a7b88784ae50437378a9661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013be3cd8287dce31f1bee2661b95f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_const_ptr_1_1_enumerator.html">Enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a013be3cd8287dce31f1bee2661b95f5b">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:a013be3cd8287dce31f1bee2661b95f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the data pointed to by this pointer   <a href="struct_const_ptr.html#a013be3cd8287dce31f1bee2661b95f5b">More...</a><br /></td></tr>
<tr class="separator:a013be3cd8287dce31f1bee2661b95f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2a9d4996325fb05abc48405c9ea647"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a4c2a9d4996325fb05abc48405c9ea647">Equals</a> (object? obj)</td></tr>
<tr class="memdesc:a4c2a9d4996325fb05abc48405c9ea647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always throws exception. Use the == operator instead   <a href="struct_const_ptr.html#a4c2a9d4996325fb05abc48405c9ea647">More...</a><br /></td></tr>
<tr class="separator:a4c2a9d4996325fb05abc48405c9ea647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93fc51c491608b32098cb5003bd1284"><td class="memItemLeft" align="right" valign="top">override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#ad93fc51c491608b32098cb5003bd1284">GetHashCode</a> ()</td></tr>
<tr class="memdesc:ad93fc51c491608b32098cb5003bd1284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always throw exceptrion.   <a href="struct_const_ptr.html#ad93fc51c491608b32098cb5003bd1284">More...</a><br /></td></tr>
<tr class="separator:ad93fc51c491608b32098cb5003bd1284"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a29d1961e30f1be33d08649417a1b1184"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a29d1961e30f1be33d08649417a1b1184">operator ConstPtr&lt; T &gt;</a> (<a class="el" href="struct_ptr.html">Ptr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a29d1961e30f1be33d08649417a1b1184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concerts <a class="el" href="struct_ptr.html" title="Mutable version of ConstPtr. Represents continuous memory. Similar to Span, but has pointer arithmeti...">Ptr</a> to <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> (same as the <a class="el" href="struct_const_ptr.html#ab6d737ad0ba4caf11a9290b991e70079" title="Creates ConstPtr from a Ptr">ConstPtr(Ptr)</a> constructor)   <a href="struct_const_ptr.html#a29d1961e30f1be33d08649417a1b1184">More...</a><br /></td></tr>
<tr class="separator:a29d1961e30f1be33d08649417a1b1184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8213292631b3610f9a6db9164736b6"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a8a8213292631b3610f9a6db9164736b6">operator ReadOnlySpan&lt; T &gt;</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a8a8213292631b3610f9a6db9164736b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> to ReadOnlySpan   <a href="struct_const_ptr.html#a8a8213292631b3610f9a6db9164736b6">More...</a><br /></td></tr>
<tr class="separator:a8a8213292631b3610f9a6db9164736b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30512b8ed4635f2f98e0d3ba0d03141"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#ab30512b8ed4635f2f98e0d3ba0d03141">operator ConstPtr&lt; T &gt;</a> (ReadOnlySpan&lt; T &gt; span)</td></tr>
<tr class="memdesc:ab30512b8ed4635f2f98e0d3ba0d03141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ReadOnlySpan to <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> (same as the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr(ReadOnlySpan)</a> constructor)   <a href="struct_const_ptr.html#ab30512b8ed4635f2f98e0d3ba0d03141">More...</a><br /></td></tr>
<tr class="separator:ab30512b8ed4635f2f98e0d3ba0d03141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cbb59431ba1a02917a4bb12911cbb3"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#af3cbb59431ba1a02917a4bb12911cbb3">operator ConstPtr&lt; T &gt;</a> (Span&lt; T &gt; span)</td></tr>
<tr class="memdesc:af3cbb59431ba1a02917a4bb12911cbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Span to <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> (same as the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr(Span)</a> constructor)   <a href="struct_const_ptr.html#af3cbb59431ba1a02917a4bb12911cbb3">More...</a><br /></td></tr>
<tr class="separator:af3cbb59431ba1a02917a4bb12911cbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9f04c9fab953b4e25b6a48aa6e7e0b"><td class="memItemLeft" align="right" valign="top">static implicit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#aca9f04c9fab953b4e25b6a48aa6e7e0b">operator ConstPtr&lt; T &gt;</a> (T[] arr)</td></tr>
<tr class="memdesc:aca9f04c9fab953b4e25b6a48aa6e7e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Array to <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> (Same as the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr(Array)</a> constructor)   <a href="struct_const_ptr.html#aca9f04c9fab953b4e25b6a48aa6e7e0b">More...</a><br /></td></tr>
<tr class="separator:aca9f04c9fab953b4e25b6a48aa6e7e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39f09288eef6f523f69e2e0d59edf43"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#aa39f09288eef6f523f69e2e0d59edf43">operator++</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:aa39f09288eef6f523f69e2e0d59edf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> ('++ptr' has the same effect as 'ptr = ptr[1..]')   <a href="struct_const_ptr.html#aa39f09288eef6f523f69e2e0d59edf43">More...</a><br /></td></tr>
<tr class="separator:aa39f09288eef6f523f69e2e0d59edf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c808e9a23ce2a87d162c9b586f6df2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a59c808e9a23ce2a87d162c9b586f6df2">operator true</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a59c808e9a23ce2a87d162c9b586f6df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given ptr is not empty (has the same effect as ptr.Length != 0)   <a href="struct_const_ptr.html#a59c808e9a23ce2a87d162c9b586f6df2">More...</a><br /></td></tr>
<tr class="separator:a59c808e9a23ce2a87d162c9b586f6df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1e67a3362a97ef0a8cc19295613897"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#acc1e67a3362a97ef0a8cc19295613897">operator false</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:acc1e67a3362a97ef0a8cc19295613897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given ptr is empty (has the same effect as ptr.Length == 0)   <a href="struct_const_ptr.html#acc1e67a3362a97ef0a8cc19295613897">More...</a><br /></td></tr>
<tr class="separator:acc1e67a3362a97ef0a8cc19295613897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14806f979ce8fd51ede3131b2333f8b7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a14806f979ce8fd51ede3131b2333f8b7">operator!</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a14806f979ce8fd51ede3131b2333f8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given ptr is empty (has the same effect as ptr.Length == 0)   <a href="struct_const_ptr.html#a14806f979ce8fd51ede3131b2333f8b7">More...</a><br /></td></tr>
<tr class="separator:a14806f979ce8fd51ede3131b2333f8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dcd338f961e12165447011a9ff25f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a01dcd338f961e12165447011a9ff25f5">operator+</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr, int value)</td></tr>
<tr class="memdesc:a01dcd338f961e12165447011a9ff25f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given number to the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> ('ptr + 5' has the same effect as 'ptr[5..]')   <a href="struct_const_ptr.html#a01dcd338f961e12165447011a9ff25f5">More...</a><br /></td></tr>
<tr class="separator:a01dcd338f961e12165447011a9ff25f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ced0b58a230eca8ad95ac3a738b14c8"><td class="memItemLeft" align="right" valign="top">static unsafe int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a7ced0b58a230eca8ad95ac3a738b14c8">operator-</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; p1, <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; p2)</td></tr>
<tr class="memdesc:a7ced0b58a230eca8ad95ac3a738b14c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of elements bethween the given pointers that point to the same continuous block of memory. If the pointers not't point to the same memory, the behaviour is undefined.   <a href="struct_const_ptr.html#a7ced0b58a230eca8ad95ac3a738b14c8">More...</a><br /></td></tr>
<tr class="separator:a7ced0b58a230eca8ad95ac3a738b14c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0782b52b148c0d9b790713143cf16b9a"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a0782b52b148c0d9b790713143cf16b9a">operator+</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a0782b52b148c0d9b790713143cf16b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value that the pointer points to (Same as ptr.Value)   <a href="struct_const_ptr.html#a0782b52b148c0d9b790713143cf16b9a">More...</a><br /></td></tr>
<tr class="separator:a0782b52b148c0d9b790713143cf16b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada006fc7e47fa8cf08bbffc076f0c37"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#aada006fc7e47fa8cf08bbffc076f0c37">operator==</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr1, <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr2)</td></tr>
<tr class="memdesc:aada006fc7e47fa8cf08bbffc076f0c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two pointers point to the same memory and have the same length. (This doesn't check the data itself)   <a href="struct_const_ptr.html#aada006fc7e47fa8cf08bbffc076f0c37">More...</a><br /></td></tr>
<tr class="separator:aada006fc7e47fa8cf08bbffc076f0c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1fb3bfac7728d225e3d113e288ea1b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a4d1fb3bfac7728d225e3d113e288ea1b">operator!=</a> (<a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr1, <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; ptr2)</td></tr>
<tr class="memdesc:a4d1fb3bfac7728d225e3d113e288ea1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two pointers don't point to the same memory or don't have the same length (This doesn't check the data itself)   <a href="struct_const_ptr.html#a4d1fb3bfac7728d225e3d113e288ea1b">More...</a><br /></td></tr>
<tr class="separator:a4d1fb3bfac7728d225e3d113e288ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="properties" name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:aabc0498a4f8cd3a27546f92189c55253"><td class="memItemLeft" align="right" valign="top"><a id="aabc0498a4f8cd3a27546f92189c55253" name="aabc0498a4f8cd3a27546f92189c55253"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Length</b><code> [get]</code></td></tr>
<tr class="memdesc:aabc0498a4f8cd3a27546f92189c55253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lenfth of the memory  <br /></td></tr>
<tr class="separator:aabc0498a4f8cd3a27546f92189c55253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ca694940904b73d0a82e32c5e9a30e"><td class="memItemLeft" align="right" valign="top"><a id="a49ca694940904b73d0a82e32c5e9a30e" name="a49ca694940904b73d0a82e32c5e9a30e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>Value</b><code> [get]</code></td></tr>
<tr class="memdesc:a49ca694940904b73d0a82e32c5e9a30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value at the first position  <br /></td></tr>
<tr class="separator:a49ca694940904b73d0a82e32c5e9a30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797d89b85ab2d7bcb36a4d20e0007cfa"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_ptr.html#a797d89b85ab2d7bcb36a4d20e0007cfa">this[int index]</a><code> [get]</code></td></tr>
<tr class="memdesc:a797d89b85ab2d7bcb36a4d20e0007cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the given index   <a href="struct_const_ptr.html#a797d89b85ab2d7bcb36a4d20e0007cfa">More...</a><br /></td></tr>
<tr class="separator:a797d89b85ab2d7bcb36a4d20e0007cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Read only version of <a class="el" href="struct_ptr.html" title="Mutable version of ConstPtr. Represents continuous memory. Similar to Span, but has pointer arithmeti...">Ptr</a>. Represents a countinuous region of read only memory. Same as ReadOnlySpan, but with pointer arithmetic operator overloads.  </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data in the memory</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a547b7919efc595fecc9881a62e9e6d96" name="a547b7919efc595fecc9881a62e9e6d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547b7919efc595fecc9881a62e9e6d96">&#9670;&#160;</a></span>ConstPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.<a class="el" href="struct_const_ptr.html">ConstPtr</a> </td>
          <td>(</td>
          <td class="paramtype">ReadOnlySpan&lt; T &gt;&#160;</td>
          <td class="paramname"><em>span</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from ReadOnlySpan  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>ReadOnlySpan to create the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49747e26d4e6d46b31c5838792cff9fd" name="a49747e26d4e6d46b31c5838792cff9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49747e26d4e6d46b31c5838792cff9fd">&#9670;&#160;</a></span>ConstPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.<a class="el" href="struct_const_ptr.html">ConstPtr</a> </td>
          <td>(</td>
          <td class="paramtype">Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>span</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from Span  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>Span to create the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09e53231531f0d4a4cb4eb861da3531a" name="a09e53231531f0d4a4cb4eb861da3531a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e53231531f0d4a4cb4eb861da3531a">&#9670;&#160;</a></span>ConstPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.<a class="el" href="struct_const_ptr.html">ConstPtr</a> </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from an array  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to create the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d737ad0ba4caf11a9290b991e70079" name="ab6d737ad0ba4caf11a9290b991e70079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d737ad0ba4caf11a9290b991e70079">&#9670;&#160;</a></span>ConstPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.<a class="el" href="struct_const_ptr.html">ConstPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ptr.html">Ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from a <a class="el" href="struct_ptr.html" title="Mutable version of ConstPtr. Represents continuous memory. Similar to Span, but has pointer arithmeti...">Ptr</a>  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_ptr.html" title="Mutable version of ConstPtr. Represents continuous memory. Similar to Span, but has pointer arithmeti...">Ptr</a> to create the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4c2a9d4996325fb05abc48405c9ea647" name="a4c2a9d4996325fb05abc48405c9ea647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2a9d4996325fb05abc48405c9ea647">&#9670;&#160;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override bool <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.Equals </td>
          <td>(</td>
          <td class="paramtype">object?&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always throws exception. Use the == operator instead  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Doesn't matter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>Thrown always</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a013be3cd8287dce31f1bee2661b95f5b" name="a013be3cd8287dce31f1bee2661b95f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013be3cd8287dce31f1bee2661b95f5b">&#9670;&#160;</a></span>GetEnumerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_const_ptr_1_1_enumerator.html">Enumerator</a> <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the data pointed to by this pointer  </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_const_ptr_1_1_enumerator.html" title="Enumerates data pointed to by a ConstPtr">Enumerator</a> that enumerates all the data in the memory pointed to by this pointer </dd></dl>

</div>
</div>
<a id="ad93fc51c491608b32098cb5003bd1284" name="ad93fc51c491608b32098cb5003bd1284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93fc51c491608b32098cb5003bd1284">&#9670;&#160;</a></span>GetHashCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override int <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.GetHashCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always throw exceptrion.  </p>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>Thrown always</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68bf64b06a7b88784ae50437378a9661" name="a68bf64b06a7b88784ae50437378a9661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bf64b06a7b88784ae50437378a9661">&#9670;&#160;</a></span>GetPinnableReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ref readonly T <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.GetPinnableReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to the first item in the memory  </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the firs item in the memory</dd></dl>

</div>
</div>
<a id="a29d1961e30f1be33d08649417a1b1184" name="a29d1961e30f1be33d08649417a1b1184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d1961e30f1be33d08649417a1b1184">&#9670;&#160;</a></span>operator ConstPtr&lt; T &gt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ptr.html">Ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concerts <a class="el" href="struct_ptr.html" title="Mutable version of ConstPtr. Represents continuous memory. Similar to Span, but has pointer arithmeti...">Ptr</a> to <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> (same as the <a class="el" href="struct_const_ptr.html#ab6d737ad0ba4caf11a9290b991e70079" title="Creates ConstPtr from a Ptr">ConstPtr(Ptr)</a> constructor)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The <a class="el" href="struct_ptr.html" title="Mutable version of ConstPtr. Represents continuous memory. Similar to Span, but has pointer arithmeti...">Ptr</a> to convert to <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab30512b8ed4635f2f98e0d3ba0d03141" name="ab30512b8ed4635f2f98e0d3ba0d03141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30512b8ed4635f2f98e0d3ba0d03141">&#9670;&#160;</a></span>operator ConstPtr&lt; T &gt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">ReadOnlySpan&lt; T &gt;&#160;</td>
          <td class="paramname"><em>span</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts ReadOnlySpan to <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> (same as the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr(ReadOnlySpan)</a> constructor)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>The ReadOnlySpan to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3cbb59431ba1a02917a4bb12911cbb3" name="af3cbb59431ba1a02917a4bb12911cbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cbb59431ba1a02917a4bb12911cbb3">&#9670;&#160;</a></span>operator ConstPtr&lt; T &gt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>span</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts Span to <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> (same as the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr(Span)</a> constructor)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">span</td><td>The Span to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca9f04c9fab953b4e25b6a48aa6e7e0b" name="aca9f04c9fab953b4e25b6a48aa6e7e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9f04c9fab953b4e25b6a48aa6e7e0b">&#9670;&#160;</a></span>operator ConstPtr&lt; T &gt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts Array to <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> (Same as the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr(Array)</a> constructor)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The Array to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc1e67a3362a97ef0a8cc19295613897" name="acc1e67a3362a97ef0a8cc19295613897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1e67a3362a97ef0a8cc19295613897">&#9670;&#160;</a></span>operator false()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator false </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given ptr is empty (has the same effect as ptr.Length == 0)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> to check if it is empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if ptr is empty, otherwise false</dd></dl>

</div>
</div>
<a id="a8a8213292631b3610f9a6db9164736b6" name="a8a8213292631b3610f9a6db9164736b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8213292631b3610f9a6db9164736b6">&#9670;&#160;</a></span>operator ReadOnlySpan&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static implicit <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator ReadOnlySpan&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> to ReadOnlySpan  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59c808e9a23ce2a87d162c9b586f6df2" name="a59c808e9a23ce2a87d162c9b586f6df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c808e9a23ce2a87d162c9b586f6df2">&#9670;&#160;</a></span>operator true()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator true </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given ptr is not empty (has the same effect as ptr.Length != 0)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> to check if is empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if ptr is not empty, otherwise false</dd></dl>

</div>
</div>
<a id="a14806f979ce8fd51ede3131b2333f8b7" name="a14806f979ce8fd51ede3131b2333f8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14806f979ce8fd51ede3131b2333f8b7">&#9670;&#160;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator! </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given ptr is empty (has the same effect as ptr.Length == 0)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> to check if it is empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if ptr is empty, otherwise false</dd></dl>

</div>
</div>
<a id="a4d1fb3bfac7728d225e3d113e288ea1b" name="a4d1fb3bfac7728d225e3d113e288ea1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1fb3bfac7728d225e3d113e288ea1b">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.<a class="el" href="struct_const_ptr.html#a14806f979ce8fd51ede3131b2333f8b7">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the two pointers don't point to the same memory or don't have the same length (This doesn't check the data itself)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr1</td><td>Pointer to be compared with ptr2</td></tr>
    <tr><td class="paramname">ptr2</td><td>Pointer to be compared with ptr1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two pointers don't point to the same memory or don't have the same length, otherwise false </dd></dl>

</div>
</div>
<a id="a0782b52b148c0d9b790713143cf16b9a" name="a0782b52b148c0d9b790713143cf16b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0782b52b148c0d9b790713143cf16b9a">&#9670;&#160;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value that the pointer points to (Same as ptr.Value)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to get the value from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first value of the pointer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the pointer length is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01dcd338f961e12165447011a9ff25f5" name="a01dcd338f961e12165447011a9ff25f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dcd338f961e12165447011a9ff25f5">&#9670;&#160;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given number to the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> ('ptr + 5' has the same effect as 'ptr[5..]')  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> to add the value to</td></tr>
    <tr><td class="paramname">value</td><td>Value to be added to the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> with the given offset</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the added value is larger than the ptr.Length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa39f09288eef6f523f69e2e0d59edf43" name="aa39f09288eef6f523f69e2e0d59edf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39f09288eef6f523f69e2e0d59edf43">&#9670;&#160;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator++ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> ('++ptr' has the same effect as 'ptr = ptr[1..]')  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> to increment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incremented <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the ptr length is 0</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ced0b58a230eca8ad95ac3a738b14c8" name="a7ced0b58a230eca8ad95ac3a738b14c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ced0b58a230eca8ad95ac3a738b14c8">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsafe int <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of elements bethween the given pointers that point to the same continuous block of memory. If the pointers not't point to the same memory, the behaviour is undefined.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The second part of memory</td></tr>
    <tr><td class="paramname">p2</td><td>The first part of memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements betwen the memory pointers</dd></dl>

</div>
</div>
<a id="aada006fc7e47fa8cf08bbffc076f0c37" name="aada006fc7e47fa8cf08bbffc076f0c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada006fc7e47fa8cf08bbffc076f0c37">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the two pointers point to the same memory and have the same length. (This doesn't check the data itself)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr1</td><td>Pointer to be compared with ptr2</td></tr>
    <tr><td class="paramname">ptr2</td><td>Pointer to be compared with ptr1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two pointers point to the same memory and have the same length</dd></dl>

</div>
</div>
<a id="a4dc6a3adc1612fe5375e245b3dc24e44" name="a4dc6a3adc1612fe5375e245b3dc24e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc6a3adc1612fe5375e245b3dc24e44">&#9670;&#160;</a></span>Slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt; <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.Slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns slice of the data in this <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a>  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start index of the slice</td></tr>
    <tr><td class="paramname">length</td><td>Size of the slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> over the specified range of the original <a class="el" href="struct_const_ptr.html" title="Read only version of Ptr. Represents a countinuous region of read only memory. Same as ReadOnlySpan,...">ConstPtr</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the requested slice is out of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a797d89b85ab2d7bcb36a4d20e0007cfa" name="a797d89b85ab2d7bcb36a4d20e0007cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797d89b85ab2d7bcb36a4d20e0007cfa">&#9670;&#160;</a></span>this[int index]</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="struct_const_ptr.html">ConstPtr</a>&lt; T &gt;.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value at the given index  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the value to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item at the given index</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfRangeException</td><td>Thrown when the index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Bny.General/Memory/ConstPtr.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_const_ptr.html">ConstPtr</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
